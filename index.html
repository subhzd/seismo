<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SEISMO - Earthquake Dashboard</title>
    
    <!-- Meta Tags for Social Sharing & Favicon -->
    <link rel="icon" href="seismo.png" type="image/png">
    <meta property="og:title" content="SEISMO - Live Earthquake Globe">
    <meta property="og:description" content="Live 3D earthquake visualization and seismic telemetry.">
    <meta property="og:image" content="https://seismo.aimaverick.me/seismo_og.png">
    <meta property="og:url" content="https://seismo.aimaverick.me">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="SEISMO - Live Earthquake Globe">
    <meta name="twitter:description" content="Live 3D earthquake visualization and seismic telemetry.">
    <meta name="twitter:image" content="https://seismo.aimaverick.me/seismo_og.png">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        brand: {
                            dark: '#020617',
                            panel: 'rgba(15, 23, 42, 0.75)',
                            border: 'rgba(51, 65, 85, 0.5)',
                            accent: '#38bdf8',
                            danger: '#ef4444',
                            warning: '#f59e0b'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Dependencies -->
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="tween.umd.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; color: #e2e8f0; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }
        
        /* UI Layer overrides */
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 0.5rem; padding-bottom: 2.5rem; }
        @media (min-width: 768px) { #ui-layer { padding: 1.5rem; padding-bottom: 3rem; } }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Glassmorphism Panels */
        .glass-panel {
            background: var(--tw-colors-brand-panel);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--tw-colors-brand-border);
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        @media (min-width: 768px) { ::-webkit-scrollbar { width: 6px; } }
        ::-webkit-scrollbar-track { background: rgba(15, 23, 42, 0.5); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: rgba(51, 65, 85, 0.8); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(71, 85, 105, 1); }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #38bdf8; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px rgba(56,189,248,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: rgba(51, 65, 85, 0.8); border-radius: 2px;
        }

        /* Tooltip */
        #tooltip {
            position: absolute; opacity: 0; transition: opacity 0.2s, transform 0.1s;
            pointer-events: none; z-index: 50; transform: translate(-50%, -120%);
        }

        /* Loading Overlay */
        #loader {
            position: absolute; inset: 0; z-index: 100; background: #020617;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease-out;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(56,189,248,0.2);
            border-top-color: #38bdf8; border-radius: 50%; animation: spin 1s linear infinite;
        }
        @media (min-width: 768px) { .spinner { width: 50px; height: 50px; } }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Chart Bars Animation */
        .chart-bar { transition: height 0.5s ease-out, background-color 0.3s; }

        /* Search input reset styles */
        input[type="text"]::-webkit-calendar-picker-indicator { display: none !important; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner mb-4 md:mb-6"></div>
        <div class="flex items-center gap-2 md:gap-3 mb-2">
            <img src="seismo.png" alt="Seismo" class="w-6 h-6 md:w-10 md:h-10 object-contain" onerror="this.style.display='none'">
            <h1 class="font-mono text-lg md:text-2xl tracking-widest text-brand-accent">SEISMO</h1>
        </div>
        <p class="font-mono text-[9px] md:text-xs text-slate-500" id="loader-text">INITIALIZING TELEMETRY...</p>
    </div>

    <!-- WebGL Canvas -->
    <div id="canvas-container"></div>

    <!-- Interactive Tooltip -->
    <div id="tooltip" class="glass-panel p-2.5 md:p-3 min-w-[150px] md:min-w-[200px]">
        <div class="flex justify-between items-center mb-1">
            <span class="font-mono font-bold text-sm md:text-lg" id="tt-mag">M 0.0</span>
            <span class="font-mono text-[9px] md:text-xs text-slate-400" id="tt-depth">0 km</span>
        </div>
        <div class="font-sans text-[10px] md:text-sm text-slate-200 truncate" id="tt-place">Location Name</div>
        <div class="font-mono text-[9px] md:text-xs text-brand-accent mt-1.5 md:mt-2" id="tt-time">00:00:00 UTC</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Top Section: Header & Status -->
        <div class="flex flex-row justify-between items-start pointer-events-none gap-2 w-full">
            
            <!-- Logo & Title -->
            <div class="glass-panel p-1.5 px-2.5 md:p-4 pointer-events-auto flex items-center gap-1.5 md:gap-3">
                <img src="seismo.png" alt="Icon" class="w-4 h-4 md:w-12 md:h-12 object-contain" onerror="this.style.display='none'">
                <div class="flex flex-col">
                    <h1 class="font-mono text-sm md:text-xl font-bold tracking-wider text-slate-100 leading-none mt-0.5">SEISMO</h1>
                    <p class="font-sans text-[8px] md:text-xs text-slate-400 uppercase tracking-widest hidden md:block mt-1">Global Telemetry Array</p>
                </div>
            </div>
            
            <!-- Status & Feed Selector -->
            <div class="glass-panel p-1.5 px-2.5 md:p-3 flex items-center gap-2 md:gap-4 pointer-events-auto">
                <div class="text-right flex flex-col justify-center">
                    <div class="font-mono text-[7px] md:text-[10px] text-slate-400 leading-none mb-1">DATA FEED</div>
                    <select id="feed-select" class="bg-transparent font-mono text-[9px] md:text-sm text-brand-accent outline-none cursor-pointer leading-none appearance-none">
                        <option value="all_day">24 HOURS</option>
                        <option value="all_week">7 DAYS</option>
                        <option value="all_hour">1 HOUR</option>
                    </select>
                </div>
                <div class="h-5 md:h-8 w-px bg-brand-border"></div>
                <div class="flex items-center justify-center min-w-[30px] md:min-w-[60px]">
                    <div class="w-1.5 h-1.5 md:w-2 md:h-2 rounded-full bg-green-400 animate-pulse mr-1 md:mr-2" id="sys-dot"></div>
                    <div class="font-mono text-[8px] md:text-sm text-green-400" id="sys-status">ON</div>
                </div>
            </div>
        </div>

        <!-- Middle Section: Left Dashboard & Right List -->
        <div id="middle-section" class="flex flex-col md:flex-row justify-between items-stretch flex-1 mt-1.5 md:mt-2 mb-1.5 md:mb-4 overflow-y-auto pointer-events-none gap-3 md:gap-4 scroll-smooth">
            
            <!-- Left: Executive Dashboard -->
            <div class="w-full md:w-80 flex flex-col gap-2 md:gap-3 pointer-events-auto flex-shrink-0 self-start md:sticky md:top-0 z-20">
                
                <!-- Region Locator / Search -->
                <div class="glass-panel p-2 flex items-center gap-2 relative group">
                    <svg class="w-3 h-3 md:w-4 md:h-4 text-slate-400 group-focus-within:text-brand-accent transition-colors flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    
                    <input type="text" id="region-search" placeholder="Locate region (e.g. California)..." list="region-options" class="bg-transparent border-none outline-none font-mono text-[9px] md:text-xs text-brand-accent w-full placeholder-slate-600 uppercase tracking-wide pr-14">
                    
                    <div class="absolute right-2 flex items-center gap-1.5 md:gap-2">
                        <button id="locate-me-btn" class="text-slate-400 hover:text-brand-accent flex-shrink-0 transition-colors" title="Locate Me">
                            <svg class="w-3.5 h-3.5 md:w-4 md:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v2m0 12v2m8-8h-2M6 12H4m8-5a5 5 0 100 10 5 5 0 000-10z"></path></svg>
                        </button>
                        <button id="clear-search-btn" class="hidden text-slate-400 hover:text-brand-accent flex-shrink-0 transition-colors" title="Clear Search">
                            <svg class="w-3.5 h-3.5 md:w-4 md:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                    
                    <datalist id="region-options">
                        <!-- Populated by JS -->
                    </datalist>
                </div>

                <!-- Global Metrics -->
                <div class="glass-panel p-2 md:p-4 flex-shrink-0">
                    <h2 class="font-mono text-[8px] md:text-xs text-slate-500 mb-1.5 md:mb-2 tracking-widest border-b border-brand-border pb-1">GLOBAL METRICS</h2>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                        <div>
                            <div class="font-mono text-[7px] md:text-[10px] text-slate-400">EVENTS</div>
                            <div class="font-mono text-sm md:text-xl text-slate-100" id="metric-total">0</div>
                        </div>
                        <div>
                            <div class="font-mono text-[7px] md:text-[10px] text-slate-400">MAX MAG</div>
                            <div class="font-mono text-sm md:text-xl text-brand-danger" id="metric-max">0.0</div>
                        </div>
                        <div class="hidden md:block">
                            <div class="font-mono text-[10px] text-slate-400" title="Seismic Volatility Index">VOLATILITY</div>
                            <div class="font-mono text-xl text-brand-warning flex items-baseline gap-1">
                                <span id="metric-svi">0.0</span><span class="text-[9px] text-slate-500">/100</span>
                            </div>
                        </div>
                        <div class="col-span-2 md:col-span-3 mt-0.5 md:mt-1">
                            <div class="font-mono text-[7px] md:text-[10px] text-slate-400 md:mb-0.5 flex justify-between md:block">
                                <span>TOTAL EST. ENERGY</span>
                                <span class="md:hidden text-brand-accent font-bold" id="metric-energy-mobile">0.00 TJ</span>
                            </div>
                            <div class="hidden md:block font-mono text-sm text-brand-accent" id="metric-energy">0.00 TJ</div>
                        </div>
                    </div>
                </div>

                <!-- Energy Distribution Chart (Hidden on Mobile) -->
                <div class="glass-panel p-4 flex-shrink-0 hidden md:block">
                    <h2 class="font-mono text-xs text-slate-500 mb-2 tracking-widest border-b border-brand-border pb-1">ENERGY DISTRIBUTION</h2>
                    <div id="energy-chart" class="flex items-end gap-[2px] h-10 mt-2 w-full">
                        <!-- Bars injected via JS -->
                    </div>
                    <div class="flex justify-between font-mono text-[8px] text-slate-500 mt-1">
                        <span id="chart-start">OLD</span>
                        <span>NOW</span>
                    </div>
                </div>

                <!-- Selected Target Details -->
                <div class="glass-panel p-2 md:p-4 flex-shrink-0 md:flex-1 flex flex-col opacity-50 transition-opacity duration-300 md:min-h-[130px]" id="target-panel">
                    <h2 class="font-mono text-[8px] md:text-xs text-slate-500 mb-1.5 md:mb-3 tracking-widest border-b border-brand-border pb-1">TARGET TELEMETRY</h2>
                    <div class="flex-1 flex flex-col justify-center text-center py-1 md:py-0" id="target-placeholder">
                        <div class="font-mono text-[8px] md:text-xs text-slate-500">AWAITING TARGET LOCK...</div>
                        <div class="font-sans text-[8px] md:text-[10px] text-slate-600 mt-1 hidden md:block">Click any node on the globe to acquire data.</div>
                    </div>
                    
                    <div id="target-data" class="hidden flex-col gap-1.5 md:gap-3">
                        <div class="flex items-end justify-between">
                            <div>
                                <div class="font-mono text-[7px] md:text-[10px] text-slate-400">MAGNITUDE</div>
                                <div class="font-mono text-lg md:text-3xl font-bold leading-none mt-0.5" id="td-mag">0.0</div>
                            </div>
                            <div class="text-right">
                                <div class="font-mono text-[7px] md:text-[10px] text-slate-400">DEPTH</div>
                                <div class="font-mono text-xs md:text-lg leading-none mt-0.5" id="td-depth">0 km</div>
                            </div>
                        </div>
                        <div>
                            <div class="font-mono text-[7px] md:text-[10px] text-slate-400 mb-0.5">LOCATION</div>
                            <div class="font-sans text-[9px] md:text-xs text-slate-200 leading-tight" id="td-place">--</div>
                            <div class="font-mono text-[7px] md:text-[9px] text-slate-500 mt-0.5 hidden md:block" id="td-coords"></div>
                            <div class="font-mono text-[7px] md:text-[9px] text-slate-500 hidden md:block" id="td-time"></div>
                        </div>
                        <div class="bg-brand-accent/10 border border-brand-accent/20 p-1 md:p-2 rounded mt-0.5 md:mt-0">
                            <div class="font-mono text-[6px] md:text-[9px] text-brand-accent/70">KINETIC YIELD ESTIMATE</div>
                            <div class="font-mono text-[8px] md:text-xs text-brand-accent mt-0.5" id="td-energy">0.00 Joules</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mobile Spacer: Crucial empty zone allowing touch interaction with the globe behind the UI -->
            <div class="md:hidden w-full h-[45vh] min-h-[300px] pointer-events-none flex-shrink-0"></div>

            <!-- Right: Event Log & Ranking (Hidden entirely on mobile to save space) -->
            <div class="hidden md:flex w-80 flex-col gap-4 flex-shrink-0 pointer-events-none">
                
                <!-- Intensity Ranking -->
                <div class="glass-panel p-4 flex-shrink-0 pointer-events-auto">
                    <h2 class="font-mono text-xs text-slate-500 mb-3 tracking-widest border-b border-brand-border pb-2">INTENSITY BY REGION</h2>
                    <div id="country-ranking" class="flex flex-col gap-2">
                        <!-- Populated by JS -->
                        <div class="font-mono text-[10px] text-slate-600 text-center py-2">CALCULATING...</div>
                    </div>
                </div>

                <!-- Event List -->
                <div class="glass-panel flex flex-col pointer-events-auto flex-1 h-auto">
                    <div class="p-4 border-b border-brand-border flex justify-between items-center flex-shrink-0">
                        <h2 class="font-mono text-xs text-slate-500 tracking-widest">RECENT DETECTIONS</h2>
                        <span class="flex h-2 w-2 relative">
                            <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-brand-accent opacity-75"></span>
                            <span class="relative inline-flex rounded-full h-2 w-2 bg-brand-accent"></span>
                        </span>
                    </div>
                    <div class="flex-1 overflow-y-auto p-2" id="event-list">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Globe View Controls (Zoom/Reset) -->
        <div class="fixed md:absolute right-2 md:right-auto md:left-1/2 top-[45%] md:top-auto md:bottom-28 -translate-y-1/2 md:translate-y-0 md:-translate-x-1/2 z-[60] flex flex-col md:flex-row gap-1.5 md:gap-3 pointer-events-auto">
            <button onclick="window.engine.zoom(1)" class="glass-panel w-7 h-7 md:w-10 md:h-10 flex items-center justify-center text-slate-300 hover:text-white hover:bg-slate-700 transition-colors font-mono text-sm md:text-xl leading-none shadow-lg" title="Zoom In">+</button>
            <button onclick="window.engine.zoom(-1)" class="glass-panel w-7 h-7 md:w-10 md:h-10 flex items-center justify-center text-slate-300 hover:text-white hover:bg-slate-700 transition-colors font-mono text-sm md:text-xl leading-none shadow-lg" title="Zoom Out">-</button>
            <button onclick="window.engine.resetGlobe()" class="glass-panel w-7 h-7 md:w-10 md:h-10 flex items-center justify-center text-slate-300 hover:text-brand-accent hover:bg-slate-700 transition-colors font-mono text-sm md:text-xl shadow-lg pb-0.5 md:pb-1" title="Reset Globe">â†º</button>
        </div>

        <!-- Bottom Section: Controls & Timeline (Ultra Compact on Mobile) -->
        <div class="glass-panel p-2 md:p-4 pointer-events-auto flex flex-col gap-0 md:gap-4 flex-shrink-0 z-30">
            
            <div class="flex flex-row justify-between items-center gap-2 md:gap-8">
                <!-- Toggles (Centered on mobile) -->
                <div class="flex flex-row justify-center gap-4 md:gap-4 w-full md:w-auto">
                    <label class="flex items-center gap-1.5 md:gap-2 cursor-pointer group">
                        <input type="checkbox" id="toggle-plates" class="hidden">
                        <div class="w-7 md:w-8 h-3.5 md:h-4 bg-slate-800 rounded-full relative transition-colors duration-300 group-hover:bg-slate-700" id="toggle-bg-plates">
                            <div class="w-3 md:w-4 h-3 md:h-4 bg-slate-400 rounded-full absolute left-0.5 top-[1px] md:top-0 md:left-0 transition-transform duration-300 scale-75 md:scale-75" id="toggle-knob-plates"></div>
                        </div>
                        <span class="font-mono text-[9px] md:text-[10px] text-slate-400 uppercase">Tectonic</span>
                    </label>
                    
                    <label class="flex items-center gap-1.5 md:gap-2 cursor-pointer group">
                        <input type="checkbox" id="toggle-heatmap" class="hidden">
                        <div class="w-7 md:w-8 h-3.5 md:h-4 bg-slate-800 rounded-full relative transition-colors duration-300 group-hover:bg-slate-700" id="toggle-bg-heat">
                            <div class="w-3 md:w-4 h-3 md:h-4 bg-slate-400 rounded-full absolute left-0.5 top-[1px] md:top-0 md:left-0 transition-transform duration-300 scale-75 md:scale-75" id="toggle-knob-heat"></div>
                        </div>
                        <span class="font-mono text-[9px] md:text-[10px] text-slate-400 uppercase">Heatmap</span>
                    </label>

                    <label class="flex items-center gap-1.5 md:gap-2 cursor-pointer group">
                        <input type="checkbox" id="toggle-autorotate" class="hidden" checked>
                        <div class="w-7 md:w-8 h-3.5 md:h-4 bg-brand-accent/20 rounded-full relative transition-colors duration-300" id="toggle-bg-rot">
                            <div class="w-3 md:w-4 h-3 md:h-4 bg-brand-accent rounded-full absolute left-0.5 top-[1px] md:top-0 md:left-0 translate-x-[12px] md:translate-x-4 transition-transform duration-300 scale-75 md:scale-75" id="toggle-knob-rot"></div>
                        </div>
                        <span class="font-mono text-[9px] md:text-[10px] text-brand-accent uppercase">Orbit</span>
                    </label>
                </div>

                <!-- Legend (Hidden on Mobile) -->
                <div class="hidden md:flex items-center gap-4 md:border-l md:border-brand-border md:pl-8">
                    <div class="font-mono text-[10px] text-slate-500">DEPTH:</div>
                    <div class="flex items-center gap-2">
                        <span class="font-mono text-[9px] text-slate-400">0km</span>
                        <div class="w-24 h-1.5 rounded bg-gradient-to-r from-red-500 via-yellow-500 to-blue-600"></div>
                        <span class="font-mono text-[9px] text-slate-400">700km+</span>
                    </div>
                </div>
            </div>

            <!-- Timeline Scrubber (Hidden on Mobile) -->
            <div class="hidden md:flex flex-col gap-1 w-full border-t border-brand-border pt-3">
                <div class="flex justify-between items-end mb-1">
                    <span class="font-mono text-[10px] text-slate-400">TIMELINE REPLAY (UTC)</span>
                    <span class="font-mono text-xs text-brand-accent" id="timeline-display">LIVE</span>
                </div>
                <input type="range" id="timeline" min="0" max="1000" value="1000">
                <div class="flex justify-between font-mono text-[9px] text-slate-600 mt-1">
                    <span id="time-start">-24H</span>
                    <span>CURRENT</span>
                </div>
            </div>

        </div>
    </div>

    <!-- Thin Sticky Footer -->
    <footer class="fixed bottom-0 left-0 w-full px-3 md:px-4 py-1.5 bg-brand-dark/90 backdrop-blur-md border-t border-brand-border text-[8px] md:text-[10px] text-slate-500 font-mono z-[100] flex justify-between items-center pointer-events-auto">
        <div>&copy; 2026 @amsubhzd</div>
        <div>Designed by <a href="https://www.aimaverick.me" target="_blank" rel="noopener noreferrer" class="text-brand-accent hover:text-white transition-colors">AIMaverick</a></div>
    </footer>

<script>
/**
 * CORE CONFIGURATION & UTILITIES
 */
const CONFIG = {
    EARTH_RADIUS: 100,
    API_BASE: 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/',
    FETCH_INTERVAL_MS: 60000, // 60 seconds
    MAX_RETRY: 3,
    CHART_BINS: 30
};

const UTILS = {
    // Standardized Multipliers (Extreme Zoom enabled): 1.0 = Continent/Macro view, 0.2 = State/City level deep dive
    REGION_COORDS: {
        "global": { lat: 0, lon: 0, zoom: 2.5 },
        "california": { lat: 36.77, lon: -119.41, zoom: 0.25 },
        "texas": { lat: 31.96, lon: -99.90, zoom: 0.35 },
        "hawaii": { lat: 19.89, lon: -155.58, zoom: 0.2 },
        "nevada": { lat: 38.80, lon: -116.41, zoom: 0.25 },
        "washington": { lat: 47.75, lon: -120.74, zoom: 0.25 },
        "oregon": { lat: 43.80, lon: -120.55, zoom: 0.25 },
        "latin america": { lat: -15.0, lon: -60.0, zoom: 1.5 },
        "japan": { lat: 36.20, lon: 138.25, zoom: 0.35 },
        "indonesia": { lat: -0.78, lon: 113.92, zoom: 0.8 },
        "turkey": { lat: 38.96, lon: 35.24, zoom: 0.4 },
        "europe": { lat: 51.0, lon: 10.0, zoom: 1.0 },
        "oceania": { lat: -25.0, lon: 135.0, zoom: 1.5 },
        "alaska": { lat: 64.20, lon: -149.49, zoom: 0.5 },
        "philippines": { lat: 12.87, lon: 121.77, zoom: 0.4 },
        "chile": { lat: -35.67, lon: -71.54, zoom: 0.6 },
        "new zealand": { lat: -40.90, lon: 174.88, zoom: 0.4 },
        "mexico": { lat: 23.63, lon: -102.55, zoom: 0.5 },
        "middle east": { lat: 29.29, lon: 42.55, zoom: 0.8 },
        "africa": { lat: 8.78, lon: 34.50, zoom: 1.5 },
        "china": { lat: 35.86, lon: 104.19, zoom: 1.0 },
        "india": { lat: 20.59, lon: 78.96, zoom: 0.8 },
        "italy": { lat: 41.87, lon: 12.56, zoom: 0.35 },
        "iran": { lat: 32.42, lon: 53.68, zoom: 0.6 },
        "russia": { lat: 61.52, lon: 105.31, zoom: 1.5 },
        "south america": { lat: -14.23, lon: -51.92, zoom: 1.5 },
        "north america": { lat: 54.52, lon: -105.25, zoom: 1.5 },
        "asia": { lat: 34.04, lon: 100.61, zoom: 1.5 },
        "australia": { lat: -25.27, lon: 133.77, zoom: 1.2 }
    },

    // Resolves query to exact coordinates (Falls back to averaging active datastream matches)
    resolveRegionCoordinates: (query) => {
        if (!query) return null;
        const q = query.toLowerCase().trim();
        if (UTILS.REGION_COORDS[q]) return UTILS.REGION_COORDS[q];

        // Search in active dynamic events
        const matches = [];
        if (window.dataManager && window.dataManager.events) {
            window.dataManager.events.forEach(ev => {
                if (ev.place.toLowerCase().includes(q)) matches.push(ev);
            });
        }

        if (matches.length > 0) {
            let sumLat = 0, sumLon = 0;
            matches.forEach(m => { sumLat += m.lat; sumLon += m.lon; });
            return {
                lat: sumLat / matches.length,
                lon: sumLon / matches.length,
                zoom: 0.35 // Tight zoom for dynamic local findings
            };
        }
        return null;
    },

    // Converts spherical Lat/Lon to 3D Cartesian coordinates
    latLonToVector3: (lat, lon, radius) => {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        return new THREE.Vector3(
            -(radius * Math.sin(phi) * Math.cos(theta)),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
        );
    },
    
    // Gutenberg-Richter magnitude-energy conversion
    calculateEnergy: (magnitude) => Math.pow(10, 1.5 * magnitude + 4.8),
    
    formatEnergy: (joules) => {
        if (joules >= 1e15) return `${(joules / 1e15).toFixed(2)} PJ`;
        if (joules >= 1e12) return `${(joules / 1e12).toFixed(2)} TJ`;
        if (joules >= 1e9)  return `${(joules / 1e9).toFixed(2)} GJ`;
        return `${(joules / 1e6).toFixed(2)} MJ`;
    },

    // Maps depth (0-700km) to a color gradient (Red -> Yellow -> Blue)
    getDepthColor: (depth) => {
        const d = Math.max(0, Math.min(depth, 700)) / 700;
        // Hue mapping: 0 is Red, 0.65 is Blue.
        const hue = d * 0.65;
        return new THREE.Color().setHSL(hue, 1.0, 0.5);
    },

    // Calculate Sub-Solar Point for accurate Day/Night terminator lighting
    getSubSolarPoint: (date) => {
        const now = date || new Date();
        const start = new Date(now.getUTCFullYear(), 0, 0);
        const diff = now - start;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        
        // Approximate solar declination
        const declination = -23.44 * Math.cos((360/365) * (dayOfYear + 10) * (Math.PI / 180));
        
        // Calculate sub-solar longitude based on UTC time
        const utcHours = now.getUTCHours() + (now.getUTCMinutes() / 60) + (now.getUTCSeconds() / 3600);
        let longitude = 180 - (utcHours * 15);
        if (longitude < -180) longitude += 360;
        
        return { lat: declination, lon: longitude };
    },

    // Helper to extract a region/country name from USGS 'place' strings
    extractRegion: (placeString) => {
        if (!placeString) return 'Unknown';
        const parts = placeString.split(',');
        return parts.length > 1 ? parts[parts.length - 1].trim() : parts[0].trim();
    }
};


/**
 * WEBGL ENGINE MODULE
 */
class GlobeEngine {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Adjust default zoom for mobile vs desktop
        const isMobile = window.innerWidth < 768;
        this.camera.position.set(0, 150, isMobile ? 350 : 250);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.appendChild(this.renderer.domElement);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        // Lowered minimum distance to allow scraping the atmosphere (Radius is 100)
        this.controls.minDistance = 103;
        this.controls.maxDistance = 500;
        this.controls.autoRotate = true;
        this.controls.autoRotateSpeed = 0.5;

        // Ensure interactions on globe aren't blocked by UI
        this.controls.domElement.style.touchAction = 'none';

        this.markerGroup = new THREE.Group();
        this.plateGroup = new THREE.Group();
        this.scene.add(this.markerGroup);
        this.scene.add(this.plateGroup);
        this.plateGroup.visible = false; // Hidden by default

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        this.animations = [];
        this.isHeatmap = false;

        this.initGlobe();
        this.initPlates();
        this.bindEvents();
    }

    initGlobe() {
        const texLoader = new THREE.TextureLoader();
        
        // Using robust CDNs for high-res globe textures
        const dayTex = texLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
        const nightTex = texLoader.load('https://unpkg.com/three-globe/example/img/earth-night.jpg');
        const normalTex = texLoader.load('https://unpkg.com/three-globe/example/img/earth-topology.png');

        // Custom Shader for precise, astronomically accurate day/night cycle
        this.earthMaterial = new THREE.ShaderMaterial({
            uniforms: {
                dayTexture: { value: dayTex },
                nightTexture: { value: nightTex },
                normalMap: { value: normalTex },
                sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                isHeatmap: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vUv = uv;
                    // Transform normal to world space to align with absolute sun vector
                    vNormal = normalize(mat3(modelMatrix) * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D dayTexture;
                uniform sampler2D nightTexture;
                uniform vec3 sunDirection;
                uniform float isHeatmap;
                
                varying vec2 vUv;
                varying vec3 vNormal;

                void main() {
                    vec3 normal = normalize(vNormal);
                    vec3 sunDir = normalize(sunDirection);
                    
                    // Cosine of angle between normal and sun
                    float intensity = dot(normal, sunDir);
                    
                    vec4 dayColor = texture2D(dayTexture, vUv);
                    vec4 nightColor = texture2D(nightTexture, vUv);
                    
                    // Smooth transition across terminator (dawn/dusk)
                    float mixFactor = smoothstep(-0.1, 0.1, intensity);
                    
                    // Add subtle blue atmospheric scattering at terminator
                    vec3 terminatorTint = vec3(0.2, 0.5, 0.8) * (1.0 - abs(intensity)) * 0.5;
                    
                    // Boost night emissive lights
                    vec3 nightBoost = nightColor.rgb * 1.5;
                    
                    vec3 color = mix(nightBoost, dayColor.rgb, mixFactor);
                    
                    // Add terminator atmospheric effect
                    if(intensity > -0.2 && intensity < 0.2) {
                        color += terminatorTint * smoothstep(0.0, 1.0, 1.0 - abs(intensity * 5.0));
                    }
                    
                    // Heatmap mode logic
                    vec3 heatmapColor = vec3(0.02, 0.05, 0.1) + (nightColor.rgb * 0.2); // Dark background
                    color = mix(color, heatmapColor, isHeatmap);

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        const geometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS, 64, 64);
        this.earth = new THREE.Mesh(geometry, this.earthMaterial);
        this.scene.add(this.earth);

        // Add Atmospheric Outer Glow (Fresnel effect)
        const atmosGeom = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS * 1.02, 64, 64);
        const atmosMat = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                uniform float isHeatmap;
                void main() {
                    // Calculate fresnel relative to camera view
                    float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                    vec3 baseColor = vec3(0.3, 0.6, 1.0);
                    vec3 heatColor = vec3(0.1, 0.1, 0.1);
                    gl_FragColor = vec4(mix(baseColor, heatColor, isHeatmap) * intensity, 1.0);
                }
            `,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true,
            uniforms: { isHeatmap: { value: 0.0 } }
        });
        this.atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
        this.scene.add(this.atmosphere);
    }

    initPlates() {
        // Fetch raw tectonic plate geojson
        fetch('https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_boundaries.json')
            .then(res => res.json())
            .then(data => {
                const lineMat = new THREE.LineBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.3 });
                data.features.forEach(feature => {
                    if(feature.geometry.type === 'LineString') {
                        this.createPlateLine(feature.geometry.coordinates, lineMat);
                    } else if (feature.geometry.type === 'MultiLineString') {
                        feature.geometry.coordinates.forEach(coords => this.createPlateLine(coords, lineMat));
                    }
                });
            }).catch(e => console.warn("Could not load plates data", e));
    }

    createPlateLine(coords, material) {
        const points = [];
        coords.forEach(coord => {
            // GeoJSON is [lon, lat]
            points.push(UTILS.latLonToVector3(coord[1], coord[0], CONFIG.EARTH_RADIUS + 0.5));
        });
        const geom = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geom, material);
        this.plateGroup.add(line);
    }

    updateSunPosition() {
        // Real-time synchronization of solar vector
        const subSolar = UTILS.getSubSolarPoint();
        // Distance 500 for directional vector computation
        const sunPos = UTILS.latLonToVector3(subSolar.lat, subSolar.lon, 500).normalize();
        if(this.earthMaterial) {
            this.earthMaterial.uniforms.sunDirection.value.copy(sunPos);
        }
    }

    toggleHeatmap(active) {
        this.isHeatmap = active;
        const val = active ? 1.0 : 0.0;
        this.earthMaterial.uniforms.isHeatmap.value = val;
        this.atmosphere.material.uniforms.isHeatmap.value = val;
        
        // Adjust marker rendering based on mode
        this.markerGroup.children.forEach(group => {
            if(group.userData && group.userData.type === 'marker') {
                group.children.forEach(mesh => {
                    if(mesh.userData.isSpike) mesh.visible = !active;
                    if(mesh.userData.isHeatmapGlow) mesh.visible = active;
                    if(mesh.userData.isShallowGlow) mesh.visible = !active;
                });
            }
        });
    }

    addUserMarker(lat, lon) {
        // Remove existing marker and its animations
        const existing = this.scene.getObjectByName('user-location');
        if (existing) {
            this.animations = this.animations.filter(a => a.mesh.parent !== existing);
            this.scene.remove(existing);
        }

        const group = new THREE.Group();
        group.name = 'user-location';
        
        const pos = UTILS.latLonToVector3(lat, lon, CONFIG.EARTH_RADIUS + 0.2);
        group.position.copy(pos);
        group.lookAt(new THREE.Vector3(0,0,0));

        // Cyan glowing sprite base
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createRadialGradient(16,16,0, 16,16,16);
        grd.addColorStop(0, `rgba(56, 189, 248, 1)`); 
        grd.addColorStop(0.4, `rgba(56, 189, 248, 0.8)`);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,32,32);
        
        const spriteMat = new THREE.SpriteMaterial({ 
            map: new THREE.CanvasTexture(canvas),
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthTest: false
        });
        const glow = new THREE.Sprite(spriteMat);
        glow.scale.set(2, 2, 1);
        group.add(glow);

        // Infinite Pulse Animation Ring
        const ringGeom = new THREE.RingGeometry(0.1, 0.3, 32);
        const ringMat = new THREE.MeshBasicMaterial({ 
            color: 0x38bdf8, side: THREE.DoubleSide, transparent: true, blending: THREE.AdditiveBlending, depthTest: false
        });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
        
        this.animations.push({
            mesh: ring,
            scale: 1,
            opacity: 1,
            maxScale: 3.5,
            loop: true // Custom flag to keep it running
        });

        this.scene.add(group);
    }

    addMarker(quakeData, isNew = false) {
        const { id, mag, depth, lat, lon } = quakeData;
        
        // Remove existing if replacing (for diff updates)
        const existing = this.markerGroup.getObjectByName(id);
        if(existing) this.markerGroup.remove(existing);

        const group = new THREE.Group();
        group.name = id;
        group.userData = { type: 'marker', data: quakeData };

        const pos = UTILS.latLonToVector3(lat, lon, CONFIG.EARTH_RADIUS);
        group.position.copy(pos);
        group.lookAt(new THREE.Vector3(0,0,0)); // Point towards center

        const color = UTILS.getDepthColor(depth);
        const height = Math.max(0.1, Math.pow(1.5, mag) * 0.5); // Exponential scaling for impact
        
        // 1. The outward Spike (representing magnitude)
        const spikeGeom = new THREE.CylinderGeometry(0.2, 0, height, 8);
        spikeGeom.translate(0, -height/2, 0); // Origin at top, pointing down towards center because of lookAt
        const spikeMat = new THREE.MeshBasicMaterial({ color: color });
        const spike = new THREE.Mesh(spikeGeom, spikeMat);
        spike.userData.isSpike = true;
        spike.visible = !this.isHeatmap;
        group.add(spike);

        // 2. Inward root (representing depth)
        const depthScale = depth / 20; // Scale depth visually
        if(depthScale > 0.1) {
            const rootGeom = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            const pts = [new THREE.Vector3(0,0,0), new THREE.Vector3(0, depthScale, 0)];
            const lineG = new THREE.BufferGeometry().setFromPoints(pts);
            const root = new THREE.Line(lineG, rootGeom);
            group.add(root);
        }

        // 3. Surface Bloom (Sprite) - Used heavily in heatmap mode
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createRadialGradient(16,16,0, 16,16,16);
        grd.addColorStop(0, `rgba(${color.r*255},${color.g*255},${color.b*255}, 1)`);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,32,32);
        
        const spriteMat = new THREE.SpriteMaterial({ 
            map: new THREE.CanvasTexture(canvas),
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthTest: false
        });
        const glow = new THREE.Sprite(spriteMat);
        // Base size on magnitude. In heatmap, make them larger.
        const baseSize = Math.max(1, mag * 0.8);
        glow.scale.set(baseSize, baseSize, 1);
        glow.userData.isHeatmapGlow = true;
        glow.userData.baseSize = baseSize;
        glow.visible = this.isHeatmap;
        
        // Shallow glow added universally, visibility toggled based on mode
        if(depth < 30) {
            const shallowGlow = new THREE.Sprite(spriteMat);
            shallowGlow.scale.set(baseSize*0.5, baseSize*0.5, 1);
            shallowGlow.userData.isShallowGlow = true;
            shallowGlow.userData.baseSize = baseSize * 0.5;
            shallowGlow.visible = !this.isHeatmap;
            group.add(shallowGlow);
        }
        group.add(glow);

        // 4. Animation Pulse for new events (Using NormalBlending for visibility against day map)
        if(isNew) {
            const ringGeom = new THREE.RingGeometry(0.1, 0.2, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: color, side: THREE.DoubleSide, transparent: true, blending: THREE.NormalBlending, depthTest: false
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2; // Flat on surface
            group.add(ring);
            
            this.animations.push({
                mesh: ring,
                scale: 1,
                opacity: 1,
                maxScale: 2 + mag * 2
            });
        }

        this.markerGroup.add(group);
    }

    flyTo(lat, lon, zoomMultiplier = 1.0) {
        // Temporarily disable auto-rotate to allow user inspection
        this.controls.autoRotate = false;
        
        const rotToggle = document.getElementById('toggle-autorotate');
        if (rotToggle && rotToggle.checked) {
            rotToggle.checked = false;
            UIManager.updateToggles();
        }

        const targetPos = UTILS.latLonToVector3(lat, lon, CONFIG.EARTH_RADIUS);
        
        // Unified camera distance logic based on a standard multiplier
        // A multiplier of 1.0 represents a comfortable continental/macro view
        const baseDistFromCenter = window.innerWidth < 768 ? 320 : 220; 
        const surfaceDist = baseDistFromCenter - CONFIG.EARTH_RADIUS;
        
        // Calculate the proposed distance
        const proposedDist = CONFIG.EARTH_RADIUS + (surfaceDist * zoomMultiplier);
        
        // Clamp distance within reasonable OrbitControls bounds to prevent breaching surface or flying away
        const clampedDist = Math.max(this.controls.minDistance + 2, Math.min(proposedDist, this.controls.maxDistance));
        const camPos = UTILS.latLonToVector3(lat, lon, clampedDist);

        // Animate Camera Position
        new TWEEN.Tween(this.camera.position)
            .to({ x: camPos.x, y: camPos.y, z: camPos.z }, 1500)
            .easing(TWEEN.Easing.Cubic.InOut)
            .start();

        // Animate Controls Target
        new TWEEN.Tween(this.controls.target)
            .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1500)
            .easing(TWEEN.Easing.Cubic.InOut)
            .start();
    }

    focusOn(lat, lon) {
        // Standard consistent zoom multiplier for individual earthquake pinpointing
        this.flyTo(lat, lon, 0.4); // Zoom in closer on individual items
    }

    highlightMarker(id) {
        const group = this.markerGroup.getObjectByName(id);
        if (group) {
            // Strong white ping animation (NormalBlending to ensure visibility)
            const ringGeom = new THREE.RingGeometry(0.1, 0.3, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, side: THREE.DoubleSide, transparent: true, blending: THREE.NormalBlending, depthTest: false
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2; // Flat on surface
            group.add(ring);
            
            this.animations.push({
                mesh: ring,
                scale: 1,
                opacity: 1,
                maxScale: 6 // Large prominent ping
            });

            // Gentle physical bounce
            new TWEEN.Tween(group.scale)
                .to({ x: 1.5, y: 1.5, z: 1.5 }, 200)
                .yoyo(true)
                .repeat(5) // Up and down 3 times
                .start();
        }
    }

    zoom(direction) {
        const targetVec = this.controls.target.clone();
        const camVec = this.camera.position.clone();
        const diff = camVec.sub(targetVec);
        const scale = direction > 0 ? 0.6 : 1.4; // 1 for in, -1 for out
        diff.multiplyScalar(scale);
        const newPos = targetVec.add(diff);
        
        // clamp distance
        const dist = newPos.distanceTo(this.controls.target);
        if (dist < this.controls.minDistance) newPos.copy(this.controls.target).add(diff.normalize().multiplyScalar(this.controls.minDistance));
        if (dist > this.controls.maxDistance) newPos.copy(this.controls.target).add(diff.normalize().multiplyScalar(this.controls.maxDistance));

        new TWEEN.Tween(this.camera.position).to({x: newPos.x, y: newPos.y, z: newPos.z}, 400).easing(TWEEN.Easing.Quadratic.Out).start();
    }

    resetGlobe() {
        // Restore auto-rotate based on toggle state
        this.controls.autoRotate = document.getElementById('toggle-autorotate').checked;
        
        const isMobile = window.innerWidth < 768;
        new TWEEN.Tween(this.camera.position).to({x: 0, y: 150, z: isMobile ? 350 : 250}, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
        new TWEEN.Tween(this.controls.target).to({x: 0, y: 0, z: 0}, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
        
        // Remove User Location Marker if it exists
        const userMarker = this.scene.getObjectByName('user-location');
        if (userMarker) {
            this.animations = this.animations.filter(a => a.mesh.parent !== userMarker);
            this.scene.remove(userMarker);
        }

        // Clear the targeted telemetry UI & search URL params entirely
        UIManager.clearTargetLock();
        UIManager.clearRegionLock();
    }

    bindEvents() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Raycasting for Tooltips & Clicks
        const container = this.renderer.domElement;
        
        const updateMouse = (e) => {
            // Support both touch and mouse events
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            this.mouse.x = (clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            return { x: clientX, y: clientY };
        };

        const handleInteraction = (e, isClick) => {
            const screenPos = updateMouse(e);
            this.raycaster.setFromCamera(this.mouse, this.camera);
            
            const intersects = this.raycaster.intersectObjects(this.markerGroup.children, true);
            
            if(intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && obj.userData.type !== 'marker') { obj = obj.parent; }
                
                if(obj.userData.type === 'marker') {
                    const data = obj.userData.data;
                    
                    if(isClick) {
                        this.focusOn(data.lat, data.lon);
                        UIManager.setTargetLock(data);
                    } else if (e.type !== 'touchmove') { // Don't show tooltip while dragging on mobile
                        UIManager.showTooltip(screenPos.x, screenPos.y, data);
                        document.body.style.cursor = 'crosshair';
                    }
                    return;
                }
            }
            if(!isClick) {
                UIManager.hideTooltip();
                document.body.style.cursor = 'default';
            }
        };

        container.addEventListener('mousemove', (e) => handleInteraction(e, false));
        container.addEventListener('click', (e) => handleInteraction(e, true));
        // Simple touch support for selection
        container.addEventListener('touchstart', (e) => {
            if(e.touches.length === 1) handleInteraction(e, true);
        }, { passive: true });
    }

    render(time) {
        TWEEN.update(time);
        this.controls.update();
        
        // Update Sun sync every frame (overkill but precise)
        this.updateSunPosition();

        // Process animations (shockwaves)
        for(let i = this.animations.length - 1; i >= 0; i--) {
            let anim = this.animations[i];
            anim.scale += 0.1;
            // Looping animations (like user location) fade slower
            anim.opacity -= anim.loop ? 0.015 : 0.02; 
            
            if(anim.opacity <= 0 || anim.scale >= anim.maxScale) {
                if (anim.loop) {
                    // Reset to start
                    anim.scale = 1;
                    anim.opacity = 1;
                } else {
                    // Destroy
                    anim.mesh.parent.remove(anim.mesh);
                    anim.mesh.geometry.dispose();
                    anim.mesh.material.dispose();
                    this.animations.splice(i, 1);
                }
            } else {
                anim.mesh.scale.set(anim.scale, anim.scale, anim.scale);
                anim.mesh.material.opacity = anim.opacity;
            }
        }

        // Pulse effect across both Normal and Heatmap modes
        const timePhase = Date.now() * 0.003;
        this.markerGroup.children.forEach(group => {
            group.children.forEach(mesh => {
                if(mesh.userData.isHeatmapGlow && this.isHeatmap) {
                    const pulse = 1 + Math.sin(timePhase + group.position.x) * 0.2;
                    const bs = mesh.userData.baseSize;
                    mesh.scale.set(bs * pulse, bs * pulse, 1);
                } else if(mesh.userData.isShallowGlow && !this.isHeatmap) {
                    const pulse = 1 + Math.sin(timePhase + group.position.x) * 0.2;
                    const bs = mesh.userData.baseSize;
                    mesh.scale.set(bs * pulse, bs * pulse, 1);
                } else if(mesh.userData.isSpike && !this.isHeatmap) {
                    // Give the spikes a slight breathing vertical effect to feel alive
                    const pulse = 1 + Math.sin(timePhase + group.position.x * 5) * 0.05;
                    mesh.scale.set(1, pulse, 1);
                }
            });
        });

        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame((t) => this.render(t));
    }
}


/**
 * DATA MANAGEMENT MODULE
 */
class DataManager {
    constructor(engine) {
        this.engine = engine;
        this.events = new Map(); // Store by ID
        this.currentFeed = 'all_day';
        this.isScrubbing = false;
        this.scrubTime = Date.now();
    }

    async init() {
        await this.fetchData(true);
        setInterval(() => {
            if(!this.isScrubbing) this.fetchData(false);
        }, CONFIG.FETCH_INTERVAL_MS);
    }

    setFeed(feed) {
        this.currentFeed = feed;
        this.events.clear();
        // Clear existing markers
        while(this.engine.markerGroup.children.length > 0) {
            const obj = this.engine.markerGroup.children[0];
            this.engine.markerGroup.remove(obj);
        }
        
        // Clear target data so we don't show ghost telemetry after feed resets
        UIManager.clearTargetLock(); 
        
        UIManager.showSystemStatus("SWITCHING FEED...", "warning");
        this.fetchData(true);
    }

    async fetchData(isInitial = false) {
        try {
            const response = await fetch(`${CONFIG.API_BASE}${this.currentFeed}.geojson`);
            if(!response.ok) throw new Error("Network response was not ok");
            const data = await response.json();
            
            let newEventsCount = 0;
            // Adaptive memory cutoff based on feed
            let historyLimitDays = 1;
            if(this.currentFeed === 'all_week') historyLimitDays = 7;
            const cutoffTime = Date.now() - (historyLimitDays * 24 * 60 * 60 * 1000); 

            data.features.forEach(feature => {
                const id = feature.id;
                const props = feature.properties;
                const coords = feature.geometry.coordinates; // [lon, lat, depth]
                
                if (props.time < cutoffTime) return; // Ignore very old data

                if (!this.events.has(id)) {
                    const quakeData = {
                        id: id,
                        mag: props.mag,
                        place: props.place,
                        time: props.time,
                        depth: coords[2],
                        lat: coords[1],
                        lon: coords[0]
                    };
                    
                    this.events.set(id, quakeData);
                    this.engine.addMarker(quakeData, !isInitial); // Animate if not initial load
                    newEventsCount++;
                }
            });

            this.updateAggregates();
            if(isInitial) UIManager.hideLoader();
            UIManager.showSystemStatus("ON", "success");

        } catch (error) {
            console.error("Fetch Error:", error);
            UIManager.showSystemStatus("ERR", "error");
        }
    }

    updateAggregates() {
        const sorted = Array.from(this.events.values()).sort((a, b) => b.time - a.time);
        
        let totalEnergy = 0;
        let maxMag = 0;
        const countryStats = {};
        const dynamicRegions = new Set();
        
        // Window duration logic for chart & SVI
        let windowMs = 24 * 60 * 60 * 1000; 
        if(this.currentFeed === 'all_week') windowMs = 7 * 24 * 60 * 60 * 1000;
        if(this.currentFeed === 'all_hour') windowMs = 60 * 60 * 1000;
        const startTime = Date.now() - windowMs;

        const bins = new Array(CONFIG.CHART_BINS).fill(0);

        sorted.forEach(q => {
            // Base aggregations
            if(q.mag > maxMag) maxMag = q.mag;
            const energy = UTILS.calculateEnergy(q.mag);
            totalEnergy += energy;

            // Country/Region Intensity Parsing
            const region = UTILS.extractRegion(q.place);
            if(region && region !== 'Unknown') {
                dynamicRegions.add(region);
                if(!countryStats[region]) {
                    countryStats[region] = { energy: 0, maxMag: -99, count: 0, topQuake: null };
                }
                countryStats[region].energy += energy;
                countryStats[region].count += 1;
                
                // Track the strongest earthquake in this region for interactivity focus
                if(q.mag > countryStats[region].maxMag) {
                    countryStats[region].maxMag = q.mag;
                    countryStats[region].topQuake = q;
                }
            }

            // Chart Binning
            if(q.time >= startTime) {
                const binIdx = Math.floor(((q.time - startTime) / windowMs) * CONFIG.CHART_BINS);
                if(binIdx >= 0 && binIdx < CONFIG.CHART_BINS) {
                    bins[binIdx] += energy;
                }
            }
        });

        // Calculate Seismic Volatility Index (0-100 scale)
        const hourlyRate = sorted.length / (windowMs / (60 * 60 * 1000));
        let sviRaw = (maxMag * 10) + (hourlyRate * 1.5);
        const svi = Math.min(100, Math.max(0, sviRaw));

        // Sort Top Volatile Countries
        const topCountries = Object.entries(countryStats)
            .sort((a, b) => b[1].energy - a[1].energy)
            .slice(0, 5)
            .map(entry => ({ name: entry[0], stats: entry[1] }));

        UIManager.updateMetrics({
            total: this.events.size,
            maxMag: maxMag.toFixed(1),
            energy: UTILS.formatEnergy(totalEnergy),
            svi: svi.toFixed(1)
        });

        UIManager.updateChart(bins, this.currentFeed);
        UIManager.updateCountryRankings(topCountries);
        UIManager.updateList(sorted.slice(0, 50)); // Show top 50 recent
        UIManager.updateRegionOptions(Array.from(dynamicRegions));
    }

    applyTimeFilter(timestamp) {
        this.scrubTime = timestamp;
        let windowMs = 24 * 60 * 60 * 1000; 
        if(this.currentFeed === 'all_week') windowMs = 7 * 24 * 60 * 60 * 1000;
        if(this.currentFeed === 'all_hour') windowMs = 60 * 60 * 1000;

        const rangeStart = timestamp - windowMs;

        this.engine.markerGroup.children.forEach(markerObj => {
            const data = markerObj.userData.data;
            if(data.time <= timestamp && data.time >= rangeStart) {
                markerObj.visible = true;
            } else {
                markerObj.visible = false;
            }
        });
    }
}


/**
 * DOM UI MANAGER
 */
const UIManager = {
    init() {
        // Setup Toggles
        const c_plates = document.getElementById('toggle-plates');
        const c_heat = document.getElementById('toggle-heatmap');
        const c_rot = document.getElementById('toggle-autorotate');

        const bindToggle = (checkboxId, bgId, knobId, activeBgClass, activeKnobClass) => {
            document.getElementById(checkboxId).addEventListener('change', (e) => {
                const bg = document.getElementById(bgId);
                const knob = document.getElementById(knobId);
                if(e.target.checked) {
                    bg.classList.replace('bg-slate-800', activeBgClass);
                    bg.classList.remove('group-hover:bg-slate-700');
                    knob.classList.add(activeKnobClass);
                } else {
                    bg.classList.replace(activeBgClass, 'bg-slate-800');
                    bg.classList.add('group-hover:bg-slate-700');
                    knob.classList.remove(activeKnobClass);
                }
                UIManager.updateToggles();
            });
        };

        const txVal = window.innerWidth < 768 ? 'translate-x-[12px]' : 'translate-x-4';
        bindToggle('toggle-plates', 'toggle-bg-plates', 'toggle-knob-plates', 'bg-brand-accent/20', txVal);
        bindToggle('toggle-heatmap', 'toggle-bg-heat', 'toggle-knob-heat', 'bg-red-500/20', txVal);
        
        c_rot.addEventListener('change', (e) => this.updateToggles());

        // Timeline Slider
        const slider = document.getElementById('timeline');
        if (slider) {
            slider.addEventListener('input', (e) => {
                const pct = e.target.value / 1000;
                if(pct === 1.0) {
                    window.dataManager.isScrubbing = false;
                    document.getElementById('timeline-display').innerText = "LIVE";
                    document.getElementById('timeline-display').className = "font-mono text-xs text-green-400 font-bold animate-pulse";
                    window.dataManager.applyTimeFilter(Date.now()); // Show all
                } else {
                    window.dataManager.isScrubbing = true;
                    let msOffset = 24 * 60 * 60 * 1000;
                    if(window.dataManager.currentFeed === 'all_week') msOffset *= 7;
                    if(window.dataManager.currentFeed === 'all_hour') msOffset /= 24;
                    
                    const simTime = Date.now() - msOffset + (msOffset * pct);
                    
                    const d = new Date(simTime);
                    document.getElementById('timeline-display').innerText = d.toISOString().replace('T', ' ').substr(0,19);
                    document.getElementById('timeline-display').className = "font-mono text-xs text-brand-warning";
                    
                    window.dataManager.applyTimeFilter(simTime);
                }
            });
        }

        // Feed Select
        document.getElementById('feed-select').addEventListener('change', (e) => {
            window.dataManager.setFeed(e.target.value);
            const labelMap = { 'all_day': '-24H', 'all_week': '-7 DAYS', 'all_hour': '-1 HOUR' };
            const timeStartEl = document.getElementById('time-start');
            if (timeStartEl) timeStartEl.innerText = labelMap[e.target.value];
            
            if (slider) {
                slider.value = 1000;
                slider.dispatchEvent(new Event('input'));
            }
            
            // Only reset the globe perspective if NO region search is currently active
            const searchInput = document.getElementById('region-search');
            if(window.engine && (!searchInput || !searchInput.value)) {
                window.engine.resetGlobe();
            }
        });

        // Region Search Bindings
        const searchInput = document.getElementById('region-search');
        const clearBtn = document.getElementById('clear-search-btn');
        const locateBtn = document.getElementById('locate-me-btn');
        
        if (searchInput) {
            const handleSearch = (e) => {
                const val = e.target.value;
                if(val && val.toLowerCase() !== 'global' && val !== 'MY LOCATION') {
                    UIManager.executeRegionSearch(val);
                } else if (!val) {
                    window.engine.resetGlobe();
                }
            };
            
            // Track typing to show/hide the clear button
            searchInput.addEventListener('input', (e) => {
                if (clearBtn) clearBtn.classList.toggle('hidden', !e.target.value);
            });
            
            // Fires when un-focused or option clicked
            searchInput.addEventListener('change', handleSearch);
            
            // Explicitly fire on Enter key to ensure snappy dynamic searches
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSearch(e);
                }
            });
        }
        
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                window.engine.resetGlobe();
            });
        }

        if (locateBtn) {
            locateBtn.addEventListener('click', () => {
                this.locateUser();
            });
        }
    },

    locateUser() {
        this.showSystemStatus("LOCATING...", "warning");
        if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition((position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                window.engine.addUserMarker(lat, lon);
                // Ultra tight zoom for precise location
                window.engine.flyTo(lat, lon, 0.15); 

                const searchInput = document.getElementById('region-search');
                if(searchInput) {
                    searchInput.value = "MY LOCATION";
                    document.getElementById('clear-search-btn')?.classList.remove('hidden');
                }
                
                // Set parameter
                const url = new URL(window.location);
                url.searchParams.set('region', 'user_location');
                window.history.pushState({}, '', url);

                this.showSystemStatus("ON", "success");
            }, (error) => {
                console.warn("Geolocation error:", error);
                this.showSystemStatus("LOC DENIED", "error");
                setTimeout(() => this.showSystemStatus("ON", "success"), 3000);
            }, {
                enableHighAccuracy: false,
                timeout: 5000,
                maximumAge: 0
            });
        } else {
            this.showSystemStatus("UNSUPPORTED", "error");
            setTimeout(() => this.showSystemStatus("ON", "success"), 3000);
        }
    },

    executeRegionSearch(regionName) {
        const coords = UTILS.resolveRegionCoordinates(regionName);
        if(coords) {
            // Update URL to reflect the exact state without page reload
            const url = new URL(window.location);
            url.searchParams.set('region', regionName);
            window.history.pushState({}, '', url);

            // Command engine to fly to the coordinates
            window.engine.flyTo(coords.lat, coords.lon, coords.zoom);

            // Provide User Interface feedback
            const searchInput = document.getElementById('region-search');
            searchInput.value = regionName.toUpperCase(); // Format nicely
            searchInput.blur();
            
            // Ensure clear button is visible
            const clearBtn = document.getElementById('clear-search-btn');
            if(clearBtn) clearBtn.classList.remove('hidden');
        } else {
            // Region not found visual feedback
            this.showSystemStatus("REGION UNKNOWN", "warning");
            setTimeout(() => this.showSystemStatus("ON", "success"), 2500);
            this.clearRegionLock();
        }
    },

    clearRegionLock() {
        const input = document.getElementById('region-search');
        const clearBtn = document.getElementById('clear-search-btn');
        if(input) input.value = '';
        if(clearBtn) clearBtn.classList.add('hidden');
        
        const url = new URL(window.location);
        if(url.searchParams.has('region')) {
            url.searchParams.delete('region');
            window.history.pushState({}, '', url);
        }
    },

    updateRegionOptions(dynamicRegions) {
        const datalist = document.getElementById('region-options');
        if (!datalist) return;
        datalist.innerHTML = '';
        
        // 1. Add Hardcoded Macro Regions
        Object.keys(UTILS.REGION_COORDS).forEach(r => {
            if(r !== 'global') {
                const opt = document.createElement('option');
                opt.value = r.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                datalist.appendChild(opt);
            }
        });

        // 2. Add dynamic active regions missing from hardcoded dictionary
        dynamicRegions.forEach(r => {
            if(!UTILS.REGION_COORDS[r.toLowerCase()]) { 
                const opt = document.createElement('option');
                opt.value = r;
                datalist.appendChild(opt);
            }
        });
    },

    updateToggles() {
        const c_plates = document.getElementById('toggle-plates').checked;
        const c_heat = document.getElementById('toggle-heatmap').checked;
        const c_rot = document.getElementById('toggle-autorotate').checked;

        window.engine.plateGroup.visible = c_plates;
        window.engine.toggleHeatmap(c_heat);
        window.engine.controls.autoRotate = c_rot;

        const bg = document.getElementById('toggle-bg-rot');
        const knob = document.getElementById('toggle-knob-rot');
        
        // Explicitly overriding exact responsive classes instead of relying on `toggle` state
        if(c_rot) {
            bg.classList.add('bg-brand-accent/20');
            bg.classList.remove('bg-slate-800');
            knob.classList.add('translate-x-[12px]', 'md:translate-x-4');
        } else {
            bg.classList.add('bg-slate-800');
            bg.classList.remove('bg-brand-accent/20');
            knob.classList.remove('translate-x-[12px]', 'md:translate-x-4');
        }
    },

    hideLoader() {
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 1000);
    },

    showSystemStatus(msg, type) {
        const el = document.getElementById('sys-status');
        const dot = document.getElementById('sys-dot');
        el.innerText = msg;
        if(type === 'success') {
            el.className = "font-mono text-[8px] md:text-sm text-green-400";
            dot.className = "w-1.5 h-1.5 md:w-2 md:h-2 rounded-full bg-green-400 animate-pulse mr-1 md:mr-2";
        } else if(type === 'warning') {
            el.className = "font-mono text-[8px] md:text-sm text-brand-warning";
            dot.className = "w-1.5 h-1.5 md:w-2 md:h-2 rounded-full bg-brand-warning animate-pulse mr-1 md:mr-2";
        } else if(type === 'error') {
            el.className = "font-mono text-[8px] md:text-sm text-brand-danger";
            dot.className = "w-1.5 h-1.5 md:w-2 md:h-2 rounded-full bg-brand-danger animate-pulse mr-1 md:mr-2";
        }
    },

    updateMetrics({ total, maxMag, energy, svi }) {
        document.getElementById('metric-total').innerText = total;
        document.getElementById('metric-max').innerText = maxMag;
        document.getElementById('metric-energy').innerText = energy;
        document.getElementById('metric-energy-mobile').innerText = energy;
        
        const sviEl = document.getElementById('metric-svi');
        sviEl.innerText = svi;
        
        const numSvi = parseFloat(svi);
        if(numSvi > 75) sviEl.className = "text-brand-danger drop-shadow-lg";
        else if (numSvi > 40) sviEl.className = "text-brand-warning";
        else sviEl.className = "text-green-400";
    },

    updateChart(bins, currentFeed) {
        const container = document.getElementById('energy-chart');
        if (!container) return; // Hidden on mobile
        container.innerHTML = '';
        
        let maxVal = Math.max(...bins, 1);

        const labelMap = { 'all_day': '-24H', 'all_week': '-7 DAYS', 'all_hour': '-1 HOUR' };
        const startEl = document.getElementById('chart-start');
        if(startEl) startEl.innerText = labelMap[currentFeed];

        bins.forEach(val => {
            const pct = (val / maxVal) * 100;
            const bar = document.createElement('div');
            
            let bgColor = 'bg-brand-accent/40';
            if (pct > 80) bgColor = 'bg-brand-danger/80';
            else if (pct > 40) bgColor = 'bg-brand-warning/60';

            bar.className = `flex-1 rounded-t-sm chart-bar ${bgColor}`;
            bar.style.height = `${Math.max(2, pct)}%`; 
            bar.title = `Est. Energy: ${UTILS.formatEnergy(val)}`;
            container.appendChild(bar);
        });
    },

    updateCountryRankings(countries) {
        const container = document.getElementById('country-ranking');
        if (!container) return;
        container.innerHTML = '';
        
        if(countries.length === 0) {
            container.innerHTML = '<div class="font-mono text-[10px] text-slate-600 text-center py-2">NO DATA AVALIABLE</div>';
            return;
        }

        countries.forEach((country, idx) => {
            const el = document.createElement('div');
            el.className = "flex justify-between items-center bg-black/20 p-1.5 md:p-2 rounded gap-1.5 md:gap-2 cursor-pointer hover:bg-slate-800/50 transition-colors group";
            
            const maxColor = country.stats.maxMag >= 5.0 ? 'text-brand-danger' : 
                            (country.stats.maxMag >= 3.0 ? 'text-brand-warning' : 'text-brand-accent');

            el.innerHTML = `
                <div class="flex items-center gap-1.5 md:gap-2 flex-1 min-w-0">
                    <span class="font-mono text-[8px] md:text-[9px] text-slate-500 w-3">${idx + 1}.</span>
                    <span class="font-sans text-[9px] md:text-[10px] text-slate-200 truncate flex-1 group-hover:text-white transition-colors" title="${country.name}">${country.name}</span>
                </div>
                <div class="text-right flex-shrink-0">
                    <span class="font-mono text-[8px] md:text-[9px] ${maxColor} font-bold mr-1 md:mr-2">M ${country.stats.maxMag.toFixed(1)}</span>
                    <span class="font-mono text-[7px] md:text-[8px] text-slate-500">${country.stats.count} ev</span>
                </div>
            `;
            
            el.onclick = () => {
                if (country.stats.topQuake) {
                    window.engine.focusOn(country.stats.topQuake.lat, country.stats.topQuake.lon);
                    UIManager.setTargetLock(country.stats.topQuake);
                    window.engine.highlightMarker(country.stats.topQuake.id); 
                }
            };

            container.appendChild(el);
        });
    },

    updateList(events) {
        const list = document.getElementById('event-list');
        if (!list) return;
        list.innerHTML = '';
        events.forEach(ev => {
            const el = document.createElement('div');
            el.className = "p-1.5 md:p-2 border-b border-slate-800 hover:bg-slate-800/50 cursor-pointer transition-colors flex justify-between items-center group";
            
            const magColor = ev.mag >= 5.0 ? 'text-brand-danger' : (ev.mag >= 3.0 ? 'text-brand-warning' : 'text-slate-300');
            
            el.innerHTML = `
                <div class="flex-1 min-w-0 mr-2">
                    <div class="font-mono text-[10px] md:text-sm font-bold ${magColor}">M ${ev.mag.toFixed(1)}</div>
                    <div class="font-sans text-[8px] md:text-[9px] text-slate-400 truncate group-hover:text-slate-200 transition-colors">${ev.place}</div>
                </div>
                <div class="text-right flex-shrink-0">
                    <div class="font-mono text-[7px] md:text-[8px] text-slate-500">${new Date(ev.time).toLocaleTimeString()}</div>
                    <div class="font-mono text-[7px] md:text-[8px] text-brand-accent">${ev.depth.toFixed(0)}km â†“</div>
                </div>
            `;
            el.onclick = () => {
                window.engine.focusOn(ev.lat, ev.lon);
                this.setTargetLock(ev);
            };
            list.appendChild(el);
        });
    },

    showTooltip(x, y, data) {
        const tt = document.getElementById('tooltip');
        tt.style.left = x + 'px';
        tt.style.top = y + 'px';
        tt.style.opacity = '1';
        tt.style.transform = 'translate(-50%, -120%) scale(1)';

        document.getElementById('tt-mag').innerText = `M ${data.mag.toFixed(1)}`;
        document.getElementById('tt-mag').className = `font-mono font-bold text-sm md:text-lg ${data.mag >= 5.0 ? 'text-brand-danger' : 'text-slate-100'}`;
        document.getElementById('tt-depth').innerText = `${data.depth.toFixed(1)} km`;
        document.getElementById('tt-place').innerText = data.place;
        
        const d = new Date(data.time);
        document.getElementById('tt-time').innerText = d.toISOString().replace('T', ' ').substr(0, 19) + ' UTC';
    },

    hideTooltip() {
        const tt = document.getElementById('tooltip');
        tt.style.opacity = '0';
        tt.style.transform = 'translate(-50%, -100%) scale(0.95)';
    },

    setTargetLock(data) {
        document.getElementById('target-placeholder').classList.add('hidden');
        document.getElementById('target-data').classList.remove('hidden');
        document.getElementById('target-panel').classList.remove('opacity-50');

        document.getElementById('td-mag').innerText = data.mag.toFixed(1);
        document.getElementById('td-mag').className = `font-mono text-lg md:text-3xl font-bold ${data.mag >= 5.0 ? 'text-brand-danger shadow-brand-danger drop-shadow-lg' : 'text-slate-100'}`;
        
        document.getElementById('td-depth').innerText = `${data.depth.toFixed(1)} km`;
        document.getElementById('td-place').innerText = data.place;
        
        const latStr = Math.abs(data.lat).toFixed(3) + (data.lat >= 0 ? 'Â°N' : 'Â°S');
        const lonStr = Math.abs(data.lon).toFixed(3) + (data.lon >= 0 ? 'Â°E' : 'Â°W');
        
        const tdCoords = document.getElementById('td-coords');
        if(tdCoords) tdCoords.innerText = `${latStr}, ${lonStr}`;
        
        const d = new Date(data.time);
        const tdTime = document.getElementById('td-time');
        if (tdTime) tdTime.innerText = d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', timeZoneName:'short'});
        
        document.getElementById('td-energy').innerText = UTILS.formatEnergy(UTILS.calculateEnergy(data.mag));
        
        if(window.innerWidth < 768) {
            const middleSection = document.getElementById('middle-section');
            if(middleSection) middleSection.scrollTo({top: 0, behavior: 'smooth'});
        }
    },

    clearTargetLock() {
        document.getElementById('target-placeholder').classList.remove('hidden');
        document.getElementById('target-data').classList.add('hidden');
        document.getElementById('target-panel').classList.add('opacity-50');
    }
};


/**
 * APPLICATION BOOTSTRAP
 */
window.onload = () => {
    // Sequence init for dramatic effect
    setTimeout(() => {
        document.getElementById('loader-text').innerText = "ESTABLISHING UPLINK...";
    }, 500);

    UIManager.init();
    window.engine = new GlobeEngine('canvas-container');
    window.dataManager = new DataManager(window.engine);
    
    // Start Engine and Init Data
    window.engine.render();
    window.dataManager.init().then(() => {
        // Once initial data loads, check if URL commands a region focus
        const urlParams = new URLSearchParams(window.location.search);
        const urlRegion = urlParams.get('region');
        if (urlRegion && urlRegion === 'user_location') {
            UIManager.locateUser();
        } else if (urlRegion) {
            UIManager.executeRegionSearch(urlRegion);
        }
    });
};

</script>

    <script>window.va=window.va||function(){(window.va.q=window.va.q||[]).push(arguments)};</script><script src="/_vercel/insights/script.js"></script>
	<script>window.si=window.si||function(){(window.siq=window.siq||[]).push(arguments)};</script><script src="/_vercel/speed-insights/script.js"></script>	

</body>
</html>